import {
  XRHandMeshModel
} from "./chunk-DLI2BTXT.js";
import "./chunk-PJO23JXJ.js";
import {
  BoxGeometry,
  DynamicDrawUsage,
  InstancedMesh,
  Matrix4,
  MeshStandardMaterial,
  Object3D,
  SphereGeometry,
  Vector3
} from "./chunk-IS2ZBFBB.js";
import "./chunk-PR4QN5HX.js";

// node_modules/three/examples/jsm/webxr/XRHandPrimitiveModel.js
var _matrix = new Matrix4();
var _vector = new Vector3();
var XRHandPrimitiveModel = class {
  constructor(handModel, controller, path, handedness, options) {
    this.controller = controller;
    this.handModel = handModel;
    this.envMap = null;
    let geometry;
    if (!options || !options.primitive || options.primitive === "sphere") {
      geometry = new SphereGeometry(1, 10, 10);
    } else if (options.primitive === "box") {
      geometry = new BoxGeometry(1, 1, 1);
    }
    const material = new MeshStandardMaterial();
    this.handMesh = new InstancedMesh(geometry, material, 30);
    this.handMesh.frustumCulled = false;
    this.handMesh.instanceMatrix.setUsage(DynamicDrawUsage);
    this.handMesh.castShadow = true;
    this.handMesh.receiveShadow = true;
    this.handModel.add(this.handMesh);
    this.joints = [
      "wrist",
      "thumb-metacarpal",
      "thumb-phalanx-proximal",
      "thumb-phalanx-distal",
      "thumb-tip",
      "index-finger-metacarpal",
      "index-finger-phalanx-proximal",
      "index-finger-phalanx-intermediate",
      "index-finger-phalanx-distal",
      "index-finger-tip",
      "middle-finger-metacarpal",
      "middle-finger-phalanx-proximal",
      "middle-finger-phalanx-intermediate",
      "middle-finger-phalanx-distal",
      "middle-finger-tip",
      "ring-finger-metacarpal",
      "ring-finger-phalanx-proximal",
      "ring-finger-phalanx-intermediate",
      "ring-finger-phalanx-distal",
      "ring-finger-tip",
      "pinky-finger-metacarpal",
      "pinky-finger-phalanx-proximal",
      "pinky-finger-phalanx-intermediate",
      "pinky-finger-phalanx-distal",
      "pinky-finger-tip"
    ];
  }
  updateMesh() {
    const defaultRadius = 8e-3;
    const joints = this.controller.joints;
    let count = 0;
    for (let i = 0; i < this.joints.length; i++) {
      const joint = joints[this.joints[i]];
      if (joint.visible) {
        _vector.setScalar(joint.jointRadius || defaultRadius);
        _matrix.compose(joint.position, joint.quaternion, _vector);
        this.handMesh.setMatrixAt(i, _matrix);
        count++;
      }
    }
    this.handMesh.count = count;
    this.handMesh.instanceMatrix.needsUpdate = true;
  }
};

// node_modules/three/examples/jsm/webxr/XRHandModelFactory.js
var XRHandModel = class extends Object3D {
  constructor(controller) {
    super();
    this.controller = controller;
    this.motionController = null;
    this.envMap = null;
    this.mesh = null;
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    if (this.motionController) {
      this.motionController.updateMesh();
    }
  }
};
var XRHandModelFactory = class {
  constructor(gltfLoader = null, onLoad = null) {
    this.gltfLoader = gltfLoader;
    this.path = null;
    this.onLoad = onLoad;
  }
  setPath(path) {
    this.path = path;
    return this;
  }
  createHandModel(controller, profile) {
    const handModel = new XRHandModel(controller);
    controller.addEventListener("connected", (event) => {
      const xrInputSource = event.data;
      if (xrInputSource.hand && !handModel.motionController) {
        handModel.xrInputSource = xrInputSource;
        if (profile === void 0 || profile === "spheres") {
          handModel.motionController = new XRHandPrimitiveModel(handModel, controller, this.path, xrInputSource.handedness, { primitive: "sphere" });
        } else if (profile === "boxes") {
          handModel.motionController = new XRHandPrimitiveModel(handModel, controller, this.path, xrInputSource.handedness, { primitive: "box" });
        } else if (profile === "mesh") {
          handModel.motionController = new XRHandMeshModel(handModel, controller, this.path, xrInputSource.handedness, this.gltfLoader, this.onLoad);
        }
      }
      controller.visible = true;
    });
    controller.addEventListener("disconnected", () => {
      controller.visible = false;
    });
    return handModel;
  }
};
export {
  XRHandModelFactory
};
//# sourceMappingURL=three_addons_webxr_XRHandModelFactory__js.js.map
